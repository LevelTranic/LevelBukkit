From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: 404Setup <153366651+404Setup@users.noreply.github.com>
Date: Thu, 30 May 2024 21:05:07 +0800
Subject: [PATCH] Divine: Feature secure seed

The patch provided by Foldenor did not work correctly, so I replaced it with Divine's implementation

diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 5443013060b62e3bfcc51cddca96d1c0bc59fe72..7d3b8a0cb8fe81c946d8947c50a1907c72741e19 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -119,6 +119,8 @@ public class Main {
                 JvmProfiler.INSTANCE.start(Environment.SERVER);
             }
 
+            one.tranic.levelpowered.bukkit.config.LevelBukkitConfig.load(); // LevelBukkit - Load Config
+
             io.papermc.paper.plugin.PluginInitializerManager.load(optionset); // Paper
             Bootstrap.bootStrap();
             Bootstrap.validate();
diff --git a/src/main/java/net/minecraft/server/commands/SeedCommand.java b/src/main/java/net/minecraft/server/commands/SeedCommand.java
index 0b500b19a99fa6c2740c0db350a166462668df9c..501424c353a60e9ab7b1f9193604b020ffd27844 100644
--- a/src/main/java/net/minecraft/server/commands/SeedCommand.java
+++ b/src/main/java/net/minecraft/server/commands/SeedCommand.java
@@ -5,6 +5,8 @@ import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.Commands;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.ComponentUtils;
+import one.tranic.levelpowered.bukkit.config.LevelBukkitConfig;
+import space.bxteam.divinemc.seed.WorldSeedUtils;
 
 public class SeedCommand {
     public static void register(CommandDispatcher<CommandSourceStack> dispatcher, boolean dedicated) {
@@ -12,6 +14,15 @@ public class SeedCommand {
             long l = context.getSource().getLevel().getSeed();
             Component component = ComponentUtils.copyOnClickText(String.valueOf(l));
             context.getSource().sendSuccess(() -> Component.translatable("commands.seed.success", component), false);
+
+            // DivineMC start - SecureSeed Command
+            if (LevelBukkitConfig.Divine.secureSeed) {
+                WorldSeedUtils.setupGlobals(context.getSource().getLevel());
+                String seedStr = WorldSeedUtils.seedToString(WorldSeedUtils.worldSeed);
+                Component featureSeedComponent = ComponentUtils.copyOnClickText(seedStr);
+                context.getSource().sendSuccess(() -> Component.translatable(("Feature seed: %s"), featureSeedComponent), false);
+            }
+            // DivineMC end
             return (int)l;
         }));
     }
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java
index 9d10cdacb3aed2c00dc60aeb6f2cbeb48905e21f..a196f647118a12e2cacca8fabb7819a1625622c2 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java
@@ -20,6 +20,7 @@ import java.util.UUID;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
+
 import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.core.RegistryAccess;
@@ -41,10 +42,12 @@ import net.minecraft.world.level.levelgen.WorldOptions;
 import net.minecraft.world.level.levelgen.flat.FlatLevelGeneratorSettings;
 import net.minecraft.world.level.levelgen.presets.WorldPreset;
 import net.minecraft.world.level.levelgen.presets.WorldPresets;
+import one.tranic.levelpowered.bukkit.config.LevelBukkitConfig;
 import org.slf4j.Logger;
 
 // CraftBukkit start
 import joptsimple.OptionSet;
+import space.bxteam.divinemc.seed.WorldSeedUtils;
 // CraftBukkit end
 
 public class DedicatedServerProperties extends Settings<DedicatedServerProperties> {
@@ -163,7 +166,22 @@ public class DedicatedServerProperties extends Settings<DedicatedServerPropertie
         boolean flag = this.get("generate-structures", true);
         long i = WorldOptions.parseSeed(s).orElse(WorldOptions.randomSeed());
 
-        this.worldOptions = new WorldOptions(i, flag, false);
+        // DivineMC start - Implement Secure Seed
+        if (LevelBukkitConfig.Divine.secureSeed) {
+            String featureSeedString = this.get("feature-level-seed", "");
+            long[] featureSeed;
+            if (featureSeedString.isEmpty()) {
+                featureSeed = WorldSeedUtils.createRandomWorldSeed();
+            } else {
+                featureSeed = WorldSeedUtils.parseSeed(featureSeedString).orElseGet(WorldSeedUtils::createRandomWorldSeed);
+            }
+
+            this.worldOptions = new WorldOptions(i, featureSeed, flag, false);
+        } else {
+            this.worldOptions = new WorldOptions(i, flag, false);
+        }
+        // DivineMC end
+        // LevelBukkit - end
         this.worldDimensionData = new DedicatedServerProperties.WorldDimensionData((JsonObject) this.get("generator-settings", (s1) -> {
             return GsonHelper.parse(!s1.isEmpty() ? s1 : "{}");
         }, new JsonObject()), (String) this.get("level-type", (s1) -> {
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 634f60b86d43eb1542a8899ceb764ecce34f80ee..a517d9dbb2e3ba018025b350ba81aefb52ebdf48 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -15,6 +15,7 @@ import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -44,6 +45,7 @@ import net.minecraft.world.level.levelgen.RandomState;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
+import space.bxteam.divinemc.seed.WorldSeedUtils;
 
 public class ServerChunkCache extends ChunkSource {
 
@@ -682,6 +684,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public ChunkGenerator getGenerator() {
+        WorldSeedUtils.setupGlobals(level); // DivineMC - Implement Secure Seed
         return this.chunkMap.generator();
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 573cca66b905c5decb0e59c58cfa861d1788d5d3..fd4e8ad743fa22a2320c89b8a462ce25c458b249 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -14,7 +14,6 @@ import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
-import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import java.io.BufferedWriter;
 import java.io.IOException;
@@ -78,7 +77,6 @@ import net.minecraft.util.Mth;
 import net.minecraft.util.ProgressListener;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.Unit;
-import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.util.valueproviders.IntProvider;
 import net.minecraft.util.valueproviders.UniformInt;
@@ -134,16 +132,12 @@ import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.chunk.storage.EntityStorage;
 import net.minecraft.world.level.chunk.storage.RegionStorageInfo;
-import net.minecraft.world.level.chunk.storage.SimpleRegionStorage;
 import net.minecraft.world.level.dimension.BuiltinDimensionTypes;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.dimension.end.EndDragonFight;
-import net.minecraft.world.level.entity.EntityPersistentStorage;
-import net.minecraft.world.level.entity.EntityTickList;
 import net.minecraft.world.level.entity.EntityTypeTest;
 import net.minecraft.world.level.entity.LevelCallback;
 import net.minecraft.world.level.entity.LevelEntityGetter;
-import net.minecraft.world.level.entity.PersistentEntitySectionManager;
 import net.minecraft.world.level.gameevent.DynamicGameEventListener;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.gameevent.GameEventDispatcher;
@@ -180,6 +174,7 @@ import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
+import space.bxteam.divinemc.seed.WorldSeedUtils;
 // CraftBukkit end
 
 public class ServerLevel extends Level implements WorldGenLevel {
@@ -812,6 +807,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             chunkgenerator = new org.bukkit.craftbukkit.generator.CustomChunkGenerator(this, chunkgenerator, gen);
         }
         // CraftBukkit end
+        WorldSeedUtils.setupGlobals(this); // DivineMC - Implement Secure Seed
         boolean flag2 = minecraftserver.forceSynchronousWrites();
         DataFixer datafixer = minecraftserver.getFixerUpper();
         this.entityStorage = new EntityRegionFileStorage(new RegionStorageInfo(convertable_conversionsession.getLevelId(), resourcekey, "entities"), convertable_conversionsession.getDimensionPath(resourcekey).resolve("entities"), flag2); // Paper - rewrite chunk system
diff --git a/src/main/java/net/minecraft/world/entity/monster/Slime.java b/src/main/java/net/minecraft/world/entity/monster/Slime.java
index f223e78eb1204bbf5f2de38a7ce5b663800f7dc4..6874fa0593fc4630c3ec5808012141adb5d46040 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Slime.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Slime.java
@@ -45,6 +45,8 @@ import net.minecraft.world.phys.Vec3;
 // CraftBukkit start
 import java.util.ArrayList;
 import java.util.List;
+
+import one.tranic.levelpowered.bukkit.config.LevelBukkitConfig;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.EntityRemoveEvent;
 import org.bukkit.event.entity.EntityTransformEvent;
@@ -353,7 +355,10 @@ public class Slime extends Mob implements Enemy {
                 }
 
                 ChunkPos chunkcoordintpair = new ChunkPos(pos);
-                boolean flag = world.getMinecraftWorld().paperConfig().entities.spawning.allChunksAreSlimeChunks || WorldgenRandom.seedSlimeChunk(chunkcoordintpair.x, chunkcoordintpair.z, ((WorldGenLevel) world).getSeed(), world.getMinecraftWorld().spigotConfig.slimeSeed).nextInt(10) == 0; // Spigot // Paper
+                // DivineMC start - Implement Secure Seed
+                boolean isSlimeChunk = LevelBukkitConfig.Divine.secureSeed ? world.getChunk(chunkcoordintpair.x, chunkcoordintpair.z).isSlimeChunk() : WorldgenRandom.seedSlimeChunk(chunkcoordintpair.x, chunkcoordintpair.z, ((WorldGenLevel) world).getSeed(), world.getMinecraftWorld().spigotConfig.slimeSeed).nextInt(10) == 0; // Spigot // Paper
+                boolean flag = world.getMinecraftWorld().paperConfig().entities.spawning.allChunksAreSlimeChunks || isSlimeChunk;
+                // DivineMC end
 
                 // Paper start - Replace rules for Height in Slime Chunks
                 final double maxHeightSlimeChunk = world.getMinecraftWorld().paperConfig().entities.spawning.slimeSpawnHeight.slimeChunk.maximum;
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index 1ac1af72a71bbf402f0d1633a4b8c9a408917d73..5b4f8a29392a6955d2a70cfbfb7c4f17811d7569 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -56,6 +56,7 @@ import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.ticks.SerializableTickContainer;
 import net.minecraft.world.ticks.TickContainerAccess;
 import org.slf4j.Logger;
+import space.bxteam.divinemc.seed.WorldgenCryptoRandom;
 
 public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiomeSource, LightChunk, StructureAccess {
 
@@ -85,6 +86,11 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
     protected final LevelHeightAccessor levelHeightAccessor;
     protected final LevelChunkSection[] sections;
 
+    // DivineMC start - Implement Secure Seed
+    private boolean slimeChunk;
+    private boolean hasComputedSlimeChunk;
+    // DivineMC end
+
     // CraftBukkit start - SPIGOT-6814: move to IChunkAccess to account for 1.17 to 1.18 chunk upgrading.
     private static final org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry();
     public org.bukkit.craftbukkit.persistence.DirtyCraftPersistentDataContainer persistentDataContainer = new org.bukkit.craftbukkit.persistence.DirtyCraftPersistentDataContainer(ChunkAccess.DATA_TYPE_REGISTRY);
@@ -175,6 +181,17 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
         return GameEventListenerRegistry.NOOP;
     }
 
+    // DivineMC start - Implement Secure Seed
+    public boolean isSlimeChunk() {
+        if (!hasComputedSlimeChunk) {
+            hasComputedSlimeChunk = true;
+            slimeChunk = WorldgenCryptoRandom.seedSlimeChunk(chunkPos.x, chunkPos.z).nextInt(10) == 0;
+        }
+
+        return slimeChunk;
+    }
+    // DivineMC end
+
     public abstract BlockState getBlockState(final int x, final int y, final int z); // Paper
     @Nullable
     public abstract BlockState setBlockState(BlockPos pos, BlockState state, boolean moved);
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
index 9a17f3d0b53b2ab0358012e4238164f8af0a6c6e..960e290c978358fe15447cca6d7cc5f5a2a8af90 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -77,7 +77,12 @@ import net.minecraft.world.level.levelgen.structure.placement.ConcentricRingsStr
 import net.minecraft.world.level.levelgen.structure.placement.RandomSpreadStructurePlacement;
 import net.minecraft.world.level.levelgen.structure.placement.StructurePlacement;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
+import one.tranic.levelpowered.bukkit.config.LevelBukkitConfig;
 import org.apache.commons.lang3.mutable.MutableBoolean;
+// DivineMC start
+import space.bxteam.divinemc.seed.WorldgenCryptoRandom;
+import space.bxteam.divinemc.seed.WorldSeedUtils;
+// DivineMC end
 
 public abstract class ChunkGenerator {
 
@@ -341,21 +346,23 @@ public abstract class ChunkGenerator {
             SectionPos sectionposition = SectionPos.of(chunkcoordintpair, generatoraccessseed.getMinSection());
             BlockPos blockposition = sectionposition.origin();
             Registry<Structure> iregistry = generatoraccessseed.registryAccess().registryOrThrow(Registries.STRUCTURE);
-            Map<Integer, List<Structure>> map = (Map) iregistry.stream().collect(Collectors.groupingBy((structure) -> {
+            Map<Integer, List<Structure>> map = iregistry.stream().collect(Collectors.groupingBy((structure) -> {
                 return structure.step().ordinal();
             }));
-            List<FeatureSorter.StepFeatureData> list = (List) this.featuresPerStep.get();
-            WorldgenRandom seededrandom = new WorldgenRandom(new XoroshiroRandomSource(RandomSupport.generateUniqueSeed()));
+            List<FeatureSorter.StepFeatureData> list = this.featuresPerStep.get();
+            // DivineMC start - Implement Secure Seed
+            WorldgenRandom seededrandom = LevelBukkitConfig.Divine.secureSeed ? new WorldgenCryptoRandom(
+                    blockposition.getX(), blockposition.getZ(), WorldSeedUtils.Salt.UNDEFINED, 0
+            ) : new WorldgenRandom(new XoroshiroRandomSource(RandomSupport.generateUniqueSeed()));
+            // DivineMC end
             long i = seededrandom.setDecorationSeed(generatoraccessseed.getSeed(), blockposition.getX(), blockposition.getZ());
-            Set<Holder<Biome>> set = new ObjectArraySet();
+            Set<Holder<Biome>> set = new ObjectArraySet<>();
 
             ChunkPos.rangeClosed(sectionposition.chunk(), 1).forEach((chunkcoordintpair1) -> {
                 ChunkAccess ichunkaccess1 = generatoraccessseed.getChunk(chunkcoordintpair1.x, chunkcoordintpair1.z);
                 LevelChunkSection[] achunksection = ichunkaccess1.getSections();
-                int j = achunksection.length;
 
-                for (int k = 0; k < j; ++k) {
-                    LevelChunkSection chunksection = achunksection[k];
+                for (LevelChunkSection chunksection : achunksection) {
                     PalettedContainerRO<Holder<Biome>> palettedcontainerro = chunksection.getBiomes(); // CraftBukkit - decompile error
 
                     Objects.requireNonNull(set);
@@ -584,9 +591,19 @@ public abstract class ChunkGenerator {
                     ArrayList<StructureSet.StructureSelectionEntry> arraylist = new ArrayList(list.size());
 
                     arraylist.addAll(list);
-                    WorldgenRandom seededrandom = new WorldgenRandom(new LegacyRandomSource(0L));
 
-                    seededrandom.setLargeFeatureSeed(placementCalculator.getLevelSeed(), chunkcoordintpair.x, chunkcoordintpair.z);
+                    // DivineMC start - Implement Secure Seed
+                    WorldgenRandom seededrandom;
+                    if (LevelBukkitConfig.Divine.secureSeed) {
+                        seededrandom = new WorldgenCryptoRandom(
+                                chunkcoordintpair.x, chunkcoordintpair.z, WorldSeedUtils.Salt.GENERATE_FEATURE, 0
+                        );
+                    } else {
+                        seededrandom = new WorldgenRandom(new LegacyRandomSource(0L));
+
+                        seededrandom.setLargeFeatureSeed(placementCalculator.getLevelSeed(), chunkcoordintpair.x, chunkcoordintpair.z);
+                    }
+                    // DivineMC end
                     int i = 0;
 
                     StructureSet.StructureSelectionEntry structureset_a1;
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkGeneratorStructureState.java b/src/main/java/net/minecraft/world/level/chunk/ChunkGeneratorStructureState.java
index a6b6e5ea191c0e2cd7a2e4f01b89d8af40a83c1b..0c71feccdda941fbbfe81e7db6dea11d2bfd7b63 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkGeneratorStructureState.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkGeneratorStructureState.java
@@ -32,6 +32,7 @@ import net.minecraft.world.level.levelgen.structure.Structure;
 import net.minecraft.world.level.levelgen.structure.StructureSet;
 import net.minecraft.world.level.levelgen.structure.placement.ConcentricRingsStructurePlacement;
 import net.minecraft.world.level.levelgen.structure.placement.StructurePlacement;
+import one.tranic.levelpowered.bukkit.config.LevelBukkitConfig;
 import org.slf4j.Logger;
 
 // Spigot start
@@ -39,6 +40,11 @@ import net.minecraft.world.level.levelgen.structure.placement.RandomSpreadStruct
 import org.spigotmc.SpigotWorldConfig;
 // Spigot end
 
+// DivineMC start
+import space.bxteam.divinemc.seed.WorldgenCryptoRandom;
+import space.bxteam.divinemc.seed.WorldSeedUtils;
+// DivineMC end
+
 public class ChunkGeneratorStructureState {
 
     private static final Logger LOGGER = LogUtils.getLogger();
@@ -221,10 +227,22 @@ public class ChunkGeneratorStructureState {
             Stopwatch stopwatch = Stopwatch.createStarted(Util.TICKER);
             int i = placement.distance();
             int j = placement.count();
-            List<CompletableFuture<ChunkPos>> list = new ArrayList(j);
+            List<CompletableFuture<ChunkPos>> list = new ArrayList<>(j);
             int k = placement.spread();
             HolderSet<Biome> holderset = placement.preferredBiomes();
-            RandomSource randomsource = RandomSource.create();
+            // DivineMC start - Implement Secure Seed
+            RandomSource randomsource = LevelBukkitConfig.Divine.secureSeed ? new WorldgenCryptoRandom(0, 0, WorldSeedUtils.Salt.STRONGHOLDS, 0) : RandomSource.create();
+
+            if (!LevelBukkitConfig.Divine.secureSeed) {
+                // Paper start - Add missing structure set seed configs
+                if (this.conf.strongholdSeed != null && structureSetEntry.is(net.minecraft.world.level.levelgen.structure.BuiltinStructureSets.STRONGHOLDS)) {
+                    randomsource.setSeed(this.conf.strongholdSeed);
+                } else {
+                    // Paper end - Add missing structure set seed configs
+                    randomsource.setSeed(this.concentricRingsSeed);
+                } // Paper - Add missing structure set seed configs
+            }
+            // DivineMC end
 
             // Paper start - Add missing structure set seed configs
             if (this.conf.strongholdSeed != null && structureSetEntry.is(net.minecraft.world.level.levelgen.structure.BuiltinStructureSets.STRONGHOLDS)) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/status/ChunkStatus.java b/src/main/java/net/minecraft/world/level/chunk/status/ChunkStatus.java
index b81c548c0e1ac53784e9c94b34b65db5f123309c..e8420f5701f909afd195a6226c5e5b274b5b45f4 100644
--- a/src/main/java/net/minecraft/world/level/chunk/status/ChunkStatus.java
+++ b/src/main/java/net/minecraft/world/level/chunk/status/ChunkStatus.java
@@ -231,6 +231,7 @@ public class ChunkStatus {
     }
 
     public CompletableFuture<ChunkAccess> generate(WorldGenContext context, Executor executor, ToFullChunk fullChunkConverter, List<ChunkAccess> chunks) {
+        space.bxteam.divinemc.seed.WorldSeedUtils.setupGlobals(context.level()); // DivineMC - Implement Secure Seed
         ChunkAccess chunkAccess = chunks.get(chunks.size() / 2);
         ProfiledDuration profiledDuration = JvmProfiler.INSTANCE.onChunkGenerate(chunkAccess.getPos(), context.level().dimension(), this.toString());
         return this.generationTask.doWork(context, this, executor, fullChunkConverter, chunks, chunkAccess).thenApply(chunk -> {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/WorldOptions.java b/src/main/java/net/minecraft/world/level/levelgen/WorldOptions.java
index 5ae04ec610a885e2ed73e942879a27fe8640471c..21a9a46457813116201324c19bec68e4a7325b7a 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/WorldOptions.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/WorldOptions.java
@@ -5,21 +5,41 @@ import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
 import java.util.Optional;
 import java.util.OptionalLong;
+import java.util.stream.LongStream;
+
 import net.minecraft.util.RandomSource;
+import one.tranic.levelpowered.bukkit.config.LevelBukkitConfig;
 import org.apache.commons.lang3.StringUtils;
+import space.bxteam.divinemc.seed.WorldSeedUtils;
 
 public class WorldOptions {
+    // DivineMC start - Implement Secure Seed
+    private static final boolean isSecureSeedEnabled = LevelBukkitConfig.Divine.secureSeed;
+    // Foldenor - secure seed - start
     public static final MapCodec<WorldOptions> CODEC = RecordCodecBuilder.mapCodec(
-        instance -> instance.group(
-                    Codec.LONG.fieldOf("seed").stable().forGetter(WorldOptions::seed),
-                    Codec.BOOL.fieldOf("generate_features").orElse(true).stable().forGetter(WorldOptions::generateStructures),
-                    Codec.BOOL.fieldOf("bonus_chest").orElse(false).stable().forGetter(WorldOptions::generateBonusChest),
-                    Codec.STRING.lenientOptionalFieldOf("legacy_custom_options").stable().forGetter(generatorOptions -> generatorOptions.legacyCustomOptions)
-                )
-                .apply(instance, instance.stable(WorldOptions::new))
+            instance -> isSecureSeedEnabled
+                    ? instance.group(
+                            Codec.LONG.fieldOf("seed").stable().forGetter(WorldOptions::seed),
+                            Codec.LONG_STREAM.fieldOf("feature_seed").stable().forGetter(WorldOptions::featureSeedStream),
+                            Codec.BOOL.fieldOf("generate_features").orElse(true).stable().forGetter(WorldOptions::generateStructures),
+                            Codec.BOOL.fieldOf("bonus_chest").orElse(false).stable().forGetter(WorldOptions::generateBonusChest),
+                            Codec.STRING.lenientOptionalFieldOf("legacy_custom_options").stable().forGetter(generatorOptions -> generatorOptions.legacyCustomOptions)
+                    ).apply(instance, instance.stable(WorldOptions::new))
+                    : instance.group(
+                            Codec.LONG.fieldOf("seed").stable().forGetter(WorldOptions::seed),
+                            Codec.BOOL.fieldOf("generate_features").orElse(true).stable().forGetter(WorldOptions::generateStructures),
+                            Codec.BOOL.fieldOf("bonus_chest").orElse(false).stable().forGetter(WorldOptions::generateBonusChest),
+                            Codec.STRING.lenientOptionalFieldOf("legacy_custom_options").stable().forGetter(generatorOptions -> generatorOptions.legacyCustomOptions)
+                    )
+                    .apply(instance, instance.stable(WorldOptions::new))
     );
-    public static final WorldOptions DEMO_OPTIONS = new WorldOptions((long)"North Carolina".hashCode(), true, true);
+    // DivineMC end
+    public static final WorldOptions DEMO_OPTIONS = isSecureSeedEnabled ?
+            new WorldOptions((long) "North Carolina".hashCode(), WorldSeedUtils.createRandomWorldSeed(), true, true) :
+            new WorldOptions("North Carolina".hashCode(), true, true); // DivineMC - Implement Secure Seed
+    // Foldenor - secure seed - end
     private final long seed;
+    private long[] featureSeed = WorldSeedUtils.createRandomWorldSeed(); // DivineMC - Implement Secure Seed
     private final boolean generateStructures;
     private final boolean generateBonusChest;
     private final Optional<String> legacyCustomOptions;
@@ -28,10 +48,26 @@ public class WorldOptions {
         this(seed, generateStructures, bonusChest, Optional.empty());
     }
 
+    // Foldenor - secure seed - start
+    public WorldOptions(long seed, long[] featureSeed, boolean generateStructures, boolean bonusChest) {
+        this(seed, featureSeed, generateStructures, bonusChest, Optional.empty());
+    }
+
     public static WorldOptions defaultWithRandomSeed() {
-        return new WorldOptions(randomSeed(), true, false);
+        return isSecureSeedEnabled ? new WorldOptions(randomSeed(), WorldSeedUtils.createRandomWorldSeed(), true, false) : new WorldOptions(randomSeed(), true, false);
     }
 
+    private WorldOptions(long seed, LongStream featureSeed, boolean generateStructures, boolean bonusChest, Optional<String> legacyCustomOptions) {
+        this(seed, featureSeed.toArray(), generateStructures, bonusChest, legacyCustomOptions);
+    }
+
+    private WorldOptions(long seed, long[] featureSeed, boolean generateStructures, boolean bonusChest, Optional<String> legacyCustomOptions) {
+        this(seed, generateStructures, bonusChest, legacyCustomOptions);
+        this.featureSeed = featureSeed;
+    }
+    // DivineMC end
+    // Foldenor - secure seed - end
+
     private WorldOptions(long seed, boolean generateStructures, boolean bonusChest, Optional<String> legacyCustomOptions) {
         this.seed = seed;
         this.generateStructures = generateStructures;
@@ -43,6 +79,16 @@ public class WorldOptions {
         return this.seed;
     }
 
+    // DivineMC start - Implement Secure Seed
+    public long[] featureSeed() {
+        return this.featureSeed;
+    }
+
+    public LongStream featureSeedStream() {
+        return LongStream.of(this.featureSeed);
+    }
+    // DivineMC end
+
     public boolean generateStructures() {
         return this.generateStructures;
     }
@@ -56,16 +102,17 @@ public class WorldOptions {
     }
 
     public WorldOptions withBonusChest(boolean bonusChest) {
-        return new WorldOptions(this.seed, this.generateStructures, bonusChest, this.legacyCustomOptions);
+        return isSecureSeedEnabled ? new WorldOptions(this.seed, this.featureSeed, this.generateStructures, bonusChest, this.legacyCustomOptions) : new WorldOptions(this.seed, this.generateStructures, bonusChest, this.legacyCustomOptions);
     }
 
     public WorldOptions withStructures(boolean structures) {
-        return new WorldOptions(this.seed, structures, this.generateBonusChest, this.legacyCustomOptions);
+        return isSecureSeedEnabled ? new WorldOptions(this.seed, this.featureSeed, structures, this.generateBonusChest, this.legacyCustomOptions) : new WorldOptions(this.seed, structures, this.generateBonusChest, this.legacyCustomOptions);
     }
 
     public WorldOptions withSeed(OptionalLong seed) {
-        return new WorldOptions(seed.orElse(randomSeed()), this.generateStructures, this.generateBonusChest, this.legacyCustomOptions);
+        return isSecureSeedEnabled ? new WorldOptions(seed.orElse(randomSeed()), WorldSeedUtils.createRandomWorldSeed(), this.generateStructures, this.generateBonusChest, this.legacyCustomOptions) : new WorldOptions(seed.orElse(randomSeed()), this.generateStructures, this.generateBonusChest, this.legacyCustomOptions);
     }
+    // DivineMC end
 
     public static OptionalLong parseSeed(String seed) {
         seed = seed.trim();
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java
index 17d2bb3f7d158ec1230a1ad7c52b9feeda586630..0b212bbd6babde2dad0e7899c333935fb20ddbe0 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java
@@ -25,6 +25,12 @@ import net.minecraft.world.level.levelgen.feature.configurations.GeodeConfigurat
 import net.minecraft.world.level.levelgen.synth.NormalNoise;
 import net.minecraft.world.level.material.FluidState;
 
+// DivineMC start - Implement Secure Seed
+import one.tranic.levelpowered.bukkit.config.LevelBukkitConfig;
+import space.bxteam.divinemc.seed.WorldSeedUtils;
+import space.bxteam.divinemc.seed.WorldgenCryptoRandom;
+// DivineMC end
+
 public class GeodeFeature extends Feature<GeodeConfiguration> {
     private static final Direction[] DIRECTIONS = Direction.values();
 
@@ -42,7 +48,7 @@ public class GeodeFeature extends Feature<GeodeConfiguration> {
         int j = geodeConfiguration.maxGenOffset;
         List<Pair<BlockPos, Integer>> list = Lists.newLinkedList();
         int k = geodeConfiguration.distributionPoints.sample(randomSource);
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(worldGenLevel.getSeed()));
+        WorldgenRandom worldgenRandom = LevelBukkitConfig.Divine.secureSeed ? new WorldgenCryptoRandom(0, 0, WorldSeedUtils.Salt.GEODE_FEATURE, 0) : new WorldgenRandom(new LegacyRandomSource(worldGenLevel.getSeed())); // DivineMC - Implement Secure Seed
         NormalNoise normalNoise = NormalNoise.create(worldgenRandom, -4, 1.0);
         List<BlockPos> list2 = Lists.newLinkedList();
         double d = (double)k / (double)geodeConfiguration.outerWallDistance.getMaxValue();
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/Structure.java b/src/main/java/net/minecraft/world/level/levelgen/structure/Structure.java
index 4d7398cbe2c400791e6598c9924202a454cb56ce..1c9fd21f20f36b7cd301f43b743609a8fdf71542 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/Structure.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/Structure.java
@@ -39,6 +39,12 @@ import net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 
+// DivineMC start - Implement Secure Seed
+import one.tranic.levelpowered.bukkit.config.LevelBukkitConfig;
+import space.bxteam.divinemc.seed.WorldSeedUtils;
+import space.bxteam.divinemc.seed.WorldgenCryptoRandom;
+// DivineMC end
+
 public abstract class Structure {
     public static final Codec<Structure> DIRECT_CODEC = BuiltInRegistries.STRUCTURE_TYPE.byNameCodec().dispatch(Structure::type, StructureType::codec);
     public static final Codec<Holder<Structure>> CODEC = RegistryFileCodec.create(Registries.STRUCTURE, DIRECT_CODEC);
@@ -233,6 +239,14 @@ public abstract class Structure {
         }
 
         private static WorldgenRandom makeRandom(long seed, ChunkPos chunkPos) {
+            // DivineMC start - Implement Secure Seed
+            if (LevelBukkitConfig.Divine.secureSeed) {
+                return new WorldgenCryptoRandom(
+                        chunkPos.x, chunkPos.z, WorldSeedUtils.Salt.GENERATE_FEATURE, seed
+                );
+            }
+            // DivineMC end
+
             WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
             worldgenRandom.setLargeFeatureSeed(seed, chunkPos.x, chunkPos.z);
             return worldgenRandom;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/placement/RandomSpreadStructurePlacement.java b/src/main/java/net/minecraft/world/level/levelgen/structure/placement/RandomSpreadStructurePlacement.java
index f873a0a0734b4fe74ba5b5f8ae0cc3c78fa76b9f..2afd881d56b995b3c8caba33e0eaf22845f2f904 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/placement/RandomSpreadStructurePlacement.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/placement/RandomSpreadStructurePlacement.java
@@ -11,6 +11,12 @@ import net.minecraft.world.level.chunk.ChunkGeneratorStructureState;
 import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 
+// DivineMC start - Implement Secure Seed
+import one.tranic.levelpowered.bukkit.config.LevelBukkitConfig;
+import space.bxteam.divinemc.seed.WorldSeedUtils;
+import space.bxteam.divinemc.seed.WorldgenCryptoRandom;
+// DivineMC end
+
 public class RandomSpreadStructurePlacement extends StructurePlacement {
     public static final MapCodec<RandomSpreadStructurePlacement> CODEC = RecordCodecBuilder.<RandomSpreadStructurePlacement>mapCodec(
             instance -> placementCodec(instance)
@@ -71,8 +77,17 @@ public class RandomSpreadStructurePlacement extends StructurePlacement {
     public ChunkPos getPotentialStructureChunk(long seed, int chunkX, int chunkZ) {
         int i = Math.floorDiv(chunkX, this.spacing);
         int j = Math.floorDiv(chunkZ, this.spacing);
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setLargeFeatureWithSalt(seed, i, j, this.salt());
+        // DivineMC start - Implement Secure Seed
+        WorldgenRandom worldgenRandom;
+        if (LevelBukkitConfig.Divine.secureSeed) {
+            worldgenRandom = new WorldgenCryptoRandom(
+                    i, j, WorldSeedUtils.Salt.POTENTIONAL_FEATURE, this.salt
+            );
+        } else {
+            worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
+            worldgenRandom.setLargeFeatureWithSalt(seed, i, j, this.salt());
+        }
+        // DivineMC end
         int k = this.spacing - this.separation;
         int l = this.spreadType.evaluate(worldgenRandom, k);
         int m = this.spreadType.evaluate(worldgenRandom, k);
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/placement/StructurePlacement.java b/src/main/java/net/minecraft/world/level/levelgen/structure/placement/StructurePlacement.java
index cbf13e4f2da6a27619e9bc9a7cd73bb6e69cad2a..ccb041146b9aca5e74d825c47f517246f59d7fa5 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/placement/StructurePlacement.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/placement/StructurePlacement.java
@@ -6,6 +6,7 @@ import com.mojang.serialization.codecs.RecordCodecBuilder;
 import com.mojang.serialization.codecs.RecordCodecBuilder.Instance;
 import com.mojang.serialization.codecs.RecordCodecBuilder.Mu;
 import java.util.Optional;
+
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.core.Vec3i;
@@ -19,6 +20,9 @@ import net.minecraft.world.level.chunk.ChunkGeneratorStructureState;
 import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.structure.StructureSet;
+import one.tranic.levelpowered.bukkit.config.LevelBukkitConfig;
+import space.bxteam.divinemc.seed.WorldSeedUtils;
+import space.bxteam.divinemc.seed.WorldgenCryptoRandom;
 
 public abstract class StructurePlacement {
     public static final Codec<StructurePlacement> CODEC = BuiltInRegistries.STRUCTURE_PLACEMENT
@@ -118,16 +122,25 @@ public abstract class StructurePlacement {
     public abstract StructurePlacementType<?> type();
 
     private static boolean probabilityReducer(long seed, int salt, int chunkX, int chunkZ, float frequency, @org.jetbrains.annotations.Nullable Integer saltOverride) { // Paper - Add missing structure set seed configs; ignore here
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setLargeFeatureWithSalt(seed, salt, chunkX, chunkZ);
+        // DivineMC start - Implement Secure Seed
+        WorldgenRandom worldgenRandom;
+        if (LevelBukkitConfig.Divine.secureSeed) {
+            worldgenRandom = new WorldgenCryptoRandom(
+                    chunkX, chunkZ, WorldSeedUtils.Salt.UNDEFINED, salt
+            );
+        } else {
+            worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
+            worldgenRandom.setLargeFeatureWithSalt(seed, salt, chunkX, chunkZ);
+        }
+        // DivineMC end
         return worldgenRandom.nextFloat() < frequency;
     }
 
     private static boolean legacyProbabilityReducerWithDouble(long seed, int salt, int chunkX, int chunkZ, float frequency, @org.jetbrains.annotations.Nullable Integer saltOverride) { // Paper - Add missing structure set seed configs
         WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
         if (saltOverride == null) { // Paper - Add missing structure set seed configs
-        worldgenRandom.setLargeFeatureSeed(seed, chunkX, chunkZ);
-        // Paper start - Add missing structure set seed configs
+            worldgenRandom.setLargeFeatureSeed(seed, chunkX, chunkZ);
+            // Paper start - Add missing structure set seed configs
         } else {
             worldgenRandom.setLargeFeatureWithSalt(seed, chunkX, chunkZ, saltOverride);
         }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/pools/JigsawPlacement.java b/src/main/java/net/minecraft/world/level/levelgen/structure/pools/JigsawPlacement.java
index 70dbf7267b43357578c07fcd46618f656410a8e2..69f19b7b6305598f79c5c23118d2223155e4b405 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/pools/JigsawPlacement.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/pools/JigsawPlacement.java
@@ -40,9 +40,15 @@ import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import one.tranic.levelpowered.bukkit.config.LevelBukkitConfig;
 import org.apache.commons.lang3.mutable.MutableObject;
 import org.slf4j.Logger;
 
+// DivineMC start - Implement Secure Seed
+import space.bxteam.divinemc.seed.WorldSeedUtils;
+import space.bxteam.divinemc.seed.WorldgenCryptoRandom;
+// DivineMC end
+
 public class JigsawPlacement {
     static final Logger LOGGER = LogUtils.getLogger();
 
@@ -61,7 +67,11 @@ public class JigsawPlacement {
         ChunkGenerator chunkGenerator = context.chunkGenerator();
         StructureTemplateManager structureTemplateManager = context.structureTemplateManager();
         LevelHeightAccessor levelHeightAccessor = context.heightAccessor();
-        WorldgenRandom worldgenRandom = context.random();
+        // DivineMC start - Implement Secure Seed
+        WorldgenRandom worldgenRandom = LevelBukkitConfig.Divine.secureSeed ? new WorldgenCryptoRandom(
+                context.chunkPos().x, context.chunkPos().z, WorldSeedUtils.Salt.JIGSAW_PLACEMENT, 0
+        ) : context.random();
+        // DivineMC end
         Registry<StructureTemplatePool> registry = registryAccess.registryOrThrow(Registries.TEMPLATE_POOL);
         Rotation rotation = Rotation.getRandom(worldgenRandom);
         StructureTemplatePool structureTemplatePool = structurePool.unwrapKey()
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index 061f7ef0138d4b8d528c7aa71ec5660c1d7e3b27..e3d93cf569c62f68e2b330c029b19e29bcaed865 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -5,20 +5,14 @@ import com.google.common.base.Predicates;
 import com.mojang.serialization.Codec;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Objects;
-import java.util.concurrent.locks.LockSupport;
-import java.util.function.BooleanSupplier;
 import java.util.function.Predicate;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.core.SectionPos;
 import net.minecraft.core.registries.Registries;
-import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtOps;
 import net.minecraft.server.level.ServerLevel;
-import net.minecraft.util.thread.ProcessorMailbox;
-import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.LightLayer;
 import net.minecraft.world.level.biome.Biomes;
 import net.minecraft.world.level.block.Blocks;
@@ -30,8 +24,6 @@ import net.minecraft.world.level.chunk.PalettedContainer;
 import net.minecraft.world.level.chunk.PalettedContainerRO;
 import net.minecraft.world.level.chunk.status.ChunkStatus;
 import net.minecraft.world.level.chunk.storage.ChunkSerializer;
-import net.minecraft.world.level.chunk.storage.EntityStorage;
-import net.minecraft.world.level.entity.PersistentEntitySectionManager;
 import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.lighting.LevelLightEngine;
@@ -202,7 +194,10 @@ public class CraftChunk implements Chunk {
     @Override
     public boolean isSlimeChunk() {
         // 987234911L is deterimined in EntitySlime when seeing if a slime can spawn in a chunk
-        return this.worldServer.paperConfig().entities.spawning.allChunksAreSlimeChunks || WorldgenRandom.seedSlimeChunk(this.getX(), this.getZ(), this.getWorld().getSeed(), worldServer.spigotConfig.slimeSeed).nextInt(10) == 0; // Paper
+        // DivineMC start - Implement Secure Seed
+        boolean isSlimeChunk = one.tranic.levelpowered.bukkit.config.LevelBukkitConfig.Divine.secureSeed ? worldServer.getChunk(this.getX(), this.getZ()).isSlimeChunk() : WorldgenRandom.seedSlimeChunk(this.getX(), this.getZ(), this.getWorld().getSeed(), worldServer.spigotConfig.slimeSeed).nextInt(10) == 0; // Paper
+        return this.worldServer.paperConfig().entities.spawning.allChunksAreSlimeChunks || isSlimeChunk;
+        // DivineMC end
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 440c91e2f77f7cfd1e3112460b23a1c66d6c6fc6..247c4bf018815d22660a36b8f6d35465521c6ab9 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -111,6 +111,7 @@ import net.minecraft.world.level.storage.PlayerDataStorage;
 import net.minecraft.world.level.storage.PrimaryLevelData;
 import net.minecraft.world.level.validation.ContentValidationException;
 import net.minecraft.world.phys.Vec3;
+import one.tranic.levelpowered.bukkit.config.LevelBukkitConfig;
 import org.bukkit.BanList;
 import org.bukkit.Bukkit;
 import org.bukkit.ChatColor;
@@ -260,6 +261,7 @@ import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import space.bxteam.divinemc.seed.WorldSeedUtils;
 
 import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
@@ -1378,7 +1380,7 @@ public final class CraftServer implements Server {
             iregistrycustom_dimension = leveldataanddimensions.dimensions().dimensionsRegistryAccess();
         } else {
             LevelSettings worldsettings;
-            WorldOptions worldoptions = new WorldOptions(creator.seed(), creator.generateStructures(), false);
+            WorldOptions worldoptions = LevelBukkitConfig.Divine.secureSeed ? new WorldOptions(creator.seed(), WorldSeedUtils.createRandomWorldSeed(), creator.generateStructures(), false) : new WorldOptions(creator.seed(), creator.generateStructures(), false); // DivineMC - Implement Secure Seed
             WorldDimensions worlddimensions;
 
             DedicatedServerProperties.WorldDimensionData properties = new DedicatedServerProperties.WorldDimensionData(GsonHelper.parse((creator.generatorSettings().isEmpty()) ? "{}" : creator.generatorSettings()), creator.type().name().toLowerCase(Locale.ROOT));
diff --git a/src/main/java/space/bxteam/divinemc/seed/Hashing.java b/src/main/java/space/bxteam/divinemc/seed/Hashing.java
new file mode 100644
index 0000000000000000000000000000000000000000..a73d8ba58b9fb2d6734b7153bd2495246f878575
--- /dev/null
+++ b/src/main/java/space/bxteam/divinemc/seed/Hashing.java
@@ -0,0 +1,73 @@
+package space.bxteam.divinemc.seed;
+
+public class Hashing {
+    // https://en.wikipedia.org/wiki/BLAKE_(hash_function)
+    // https://github.com/bcgit/bc-java/blob/master/core/src/main/java/org/bouncycastle/crypto/digests/Blake2bDigest.java
+
+    private final static long[] blake2b_IV = {
+            0x6a09e667f3bcc908L, 0xbb67ae8584caa73bL, 0x3c6ef372fe94f82bL,
+            0xa54ff53a5f1d36f1L, 0x510e527fade682d1L, 0x9b05688c2b3e6c1fL,
+            0x1f83d9abfb41bd6bL, 0x5be0cd19137e2179L
+    };
+
+    private final static byte[][] blake2b_sigma = {
+            {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
+            {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},
+            {11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},
+            {7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8},
+            {9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13},
+            {2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9},
+            {12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11},
+            {13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10},
+            {6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5},
+            {10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0},
+            {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
+            {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3}
+    };
+
+    public static long[] hashWorldSeed(long[] worldSeed) {
+        long[] result = blake2b_IV.clone();
+        result[0] ^= 0x01010040;
+        hash(worldSeed, result, new long[16], 0, false);
+        return result;
+    }
+
+    public static void hash(long[] message, long[] chainValue, long[] internalState, long messageOffset, boolean isFinal) {
+        assert message.length == 16;
+        assert chainValue.length == 8;
+        assert internalState.length == 16;
+
+        System.arraycopy(chainValue, 0, internalState, 0, chainValue.length);
+        System.arraycopy(blake2b_IV, 0, internalState, chainValue.length, 4);
+        internalState[12] = messageOffset ^ blake2b_IV[4];
+        internalState[13] = blake2b_IV[5];
+        if (isFinal) internalState[14] = ~blake2b_IV[6];
+        internalState[15] = blake2b_IV[7];
+
+        for (int round = 0; round < 12; round++) {
+            G(message[blake2b_sigma[round][0]], message[blake2b_sigma[round][1]], 0, 4, 8, 12, internalState);
+            G(message[blake2b_sigma[round][2]], message[blake2b_sigma[round][3]], 1, 5, 9, 13, internalState);
+            G(message[blake2b_sigma[round][4]], message[blake2b_sigma[round][5]], 2, 6, 10, 14, internalState);
+            G(message[blake2b_sigma[round][6]], message[blake2b_sigma[round][7]], 3, 7, 11, 15, internalState);
+            G(message[blake2b_sigma[round][8]], message[blake2b_sigma[round][9]], 0, 5, 10, 15, internalState);
+            G(message[blake2b_sigma[round][10]], message[blake2b_sigma[round][11]], 1, 6, 11, 12, internalState);
+            G(message[blake2b_sigma[round][12]], message[blake2b_sigma[round][13]], 2, 7, 8, 13, internalState);
+            G(message[blake2b_sigma[round][14]], message[blake2b_sigma[round][15]], 3, 4, 9, 14, internalState);
+        }
+
+        for (int i = 0; i < 8; i++) {
+            chainValue[i] ^= internalState[i] ^ internalState[i + 8];
+        }
+    }
+
+    private static void G(long m1, long m2, int posA, int posB, int posC, int posD, long[] internalState) {
+        internalState[posA] = internalState[posA] + internalState[posB] + m1;
+        internalState[posD] = Long.rotateRight(internalState[posD] ^ internalState[posA], 32);
+        internalState[posC] = internalState[posC] + internalState[posD];
+        internalState[posB] = Long.rotateRight(internalState[posB] ^ internalState[posC], 24); // replaces 25 of BLAKE
+        internalState[posA] = internalState[posA] + internalState[posB] + m2;
+        internalState[posD] = Long.rotateRight(internalState[posD] ^ internalState[posA], 16);
+        internalState[posC] = internalState[posC] + internalState[posD];
+        internalState[posB] = Long.rotateRight(internalState[posB] ^ internalState[posC], 63); // replaces 11 of BLAKE
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/space/bxteam/divinemc/seed/WorldSeedUtils.java b/src/main/java/space/bxteam/divinemc/seed/WorldSeedUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..d074fbd595bece3eb5f3a66cc28c0bd3f9e2bb15
--- /dev/null
+++ b/src/main/java/space/bxteam/divinemc/seed/WorldSeedUtils.java
@@ -0,0 +1,97 @@
+package space.bxteam.divinemc.seed;
+
+import com.google.common.collect.Iterables;
+import net.minecraft.server.level.ServerLevel;
+import one.tranic.levelpowered.bukkit.config.LevelBukkitConfig;
+
+import java.math.BigInteger;
+import java.security.SecureRandom;
+import java.util.Optional;
+
+public class WorldSeedUtils {
+    public static final int WORLD_SEED_LONGS = 16;
+    public static final int WORLD_SEED_BITS = WORLD_SEED_LONGS * 64;
+
+    public static final long[] worldSeed = new long[WORLD_SEED_LONGS];
+    public static final ThreadLocal<Integer> dimension = ThreadLocal.withInitial(() -> 0);
+
+    public enum Salt {
+        UNDEFINED,
+        BASTION_FEATURE,
+        WOODLAND_MANSION_FEATURE,
+        MINESHAFT_FEATURE,
+        BURIED_TREASURE_FEATURE,
+        NETHER_FORTRESS_FEATURE,
+        PILLAGER_OUTPOST_FEATURE,
+        GEODE_FEATURE,
+        NETHER_FOSSIL_FEATURE,
+        OCEAN_MONUMENT_FEATURE,
+        RUINED_PORTAL_FEATURE,
+        POTENTIONAL_FEATURE,
+        GENERATE_FEATURE,
+        JIGSAW_PLACEMENT,
+        STRONGHOLDS,
+        POPULATION,
+        DECORATION,
+        SLIME_CHUNK
+    }
+
+    public static void setupGlobals(ServerLevel world) {
+        if (!LevelBukkitConfig.Divine.secureSeed) return;
+
+        long[] seed = world.getServer().getWorldData().worldGenOptions().featureSeed();
+        System.arraycopy(seed, 0, worldSeed, 0, WORLD_SEED_LONGS);
+        int worldIndex = Iterables.indexOf(world.getServer().levelKeys(), it -> it == world.dimension());
+        if (worldIndex == -1)
+            worldIndex = world.getServer().levelKeys().size(); // if we are in world construction it may not have been added to the map yet
+        dimension.set(worldIndex);
+    }
+
+    public static long[] createRandomWorldSeed() {
+        long[] seed = new long[WORLD_SEED_LONGS];
+        SecureRandom rand = new SecureRandom();
+        for (int i = 0; i < WORLD_SEED_LONGS; i++) {
+            seed[i] = rand.nextLong();
+        }
+        return seed;
+    }
+
+    public static Optional<long[]> parseSeed(String seedStr) {
+        if (seedStr.isEmpty()) return Optional.empty();
+
+        try {
+            long[] seed = new long[WORLD_SEED_LONGS];
+            BigInteger seedBigInt = new BigInteger(seedStr);
+            if (seedBigInt.signum() < 0) {
+                seedBigInt = seedBigInt.and(BigInteger.ONE.shiftLeft(WORLD_SEED_BITS).subtract(BigInteger.ONE));
+            }
+            for (int i = 0; i < WORLD_SEED_LONGS; i++) {
+                BigInteger[] divRem = seedBigInt.divideAndRemainder(BigInteger.ONE.shiftLeft(64));
+                seed[i] = divRem[1].longValue();
+                seedBigInt = divRem[0];
+            }
+            return Optional.of(seed);
+        } catch (NumberFormatException ignored) {
+            return Optional.empty();
+        }
+    }
+
+    public static String seedToString(long[] seed) {
+        BigInteger seedBigInt = BigInteger.ZERO;
+        for (int i = WORLD_SEED_LONGS - 1; i >= 0; i--) {
+            BigInteger val = BigInteger.valueOf(seed[i]);
+            if (val.signum() < 0) {
+                val = val.add(BigInteger.ONE.shiftLeft(64));
+            }
+            seedBigInt = seedBigInt.shiftLeft(64).add(val);
+        }
+
+        // Ensure the output is 1024-bit length
+        int seedLength = seedBigInt.bitLength();
+        if (seedLength < 1024) {
+            seedBigInt = seedBigInt.add(BigInteger.ONE.shiftLeft(1025 - seedLength)); // Use 1025 since the first sign bit
+        }
+
+        return seedBigInt.toString();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/space/bxteam/divinemc/seed/WorldgenCryptoRandom.java b/src/main/java/space/bxteam/divinemc/seed/WorldgenCryptoRandom.java
new file mode 100644
index 0000000000000000000000000000000000000000..900ad724c209a0c43e861e881c91ca250506e7cc
--- /dev/null
+++ b/src/main/java/space/bxteam/divinemc/seed/WorldgenCryptoRandom.java
@@ -0,0 +1,158 @@
+package space.bxteam.divinemc.seed;
+
+import net.minecraft.util.Mth;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.level.levelgen.LegacyRandomSource;
+import net.minecraft.world.level.levelgen.WorldgenRandom;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Arrays;
+
+public class WorldgenCryptoRandom extends WorldgenRandom {
+    // hash the world seed to guard against badly chosen world seeds
+    private static final long[] HASHED_ZERO_SEED = Hashing.hashWorldSeed(new long[WorldSeedUtils.WORLD_SEED_LONGS]);
+    private static final ThreadLocal<long[]> LAST_SEEN_WORLD_SEED = ThreadLocal.withInitial(() -> new long[WorldSeedUtils.WORLD_SEED_LONGS]);
+    private static final ThreadLocal<long[]> HASHED_WORLD_SEED = ThreadLocal.withInitial(() -> HASHED_ZERO_SEED);
+
+    private final long[] worldSeed = new long[WorldSeedUtils.WORLD_SEED_LONGS];
+    private final long[] randomBits = new long[8];
+    private int randomBitIndex;
+    private static final int MAX_RANDOM_BIT_INDEX = 64 * 8;
+    private static final int LOG2_MAX_RANDOM_BIT_INDEX = 9;
+    private long counter;
+    private final long[] message = new long[16];
+    private final long[] cachedInternalState = new long[16];
+
+    public WorldgenCryptoRandom(int x, int z, WorldSeedUtils.Salt typeSalt, long salt) {
+        super(new LegacyRandomSource(0L));
+        if (typeSalt != null) {
+            this.setSecureSeed(x, z, typeSalt, salt);
+        }
+    }
+
+    public void setSecureSeed(int x, int z, WorldSeedUtils.Salt typeSalt, long salt) {
+        System.arraycopy(WorldSeedUtils.worldSeed, 0, this.worldSeed, 0, WorldSeedUtils.WORLD_SEED_LONGS);
+        message[0] = ((long) x << 32) | ((long) z & 0xffffffffL);
+        message[1] = ((long) WorldSeedUtils.dimension.get() << 32) | ((long) salt & 0xffffffffL);
+        message[2] = typeSalt.ordinal();
+        message[3] = counter = 0;
+        randomBitIndex = MAX_RANDOM_BIT_INDEX;
+    }
+
+    private long[] getHashedWorldSeed() {
+        if (!Arrays.equals(worldSeed, LAST_SEEN_WORLD_SEED.get())) {
+            HASHED_WORLD_SEED.set(Hashing.hashWorldSeed(worldSeed));
+            System.arraycopy(worldSeed, 0, LAST_SEEN_WORLD_SEED.get(), 0, WorldSeedUtils.WORLD_SEED_LONGS);
+        }
+        return HASHED_WORLD_SEED.get();
+    }
+
+    private void moreRandomBits() {
+        message[3] = counter++;
+        System.arraycopy(getHashedWorldSeed(), 0, randomBits, 0, 8);
+        Hashing.hash(message, randomBits, cachedInternalState, 64, true);
+    }
+
+    private long getBits(int count) {
+        if (randomBitIndex >= MAX_RANDOM_BIT_INDEX) {
+            moreRandomBits();
+            randomBitIndex -= MAX_RANDOM_BIT_INDEX;
+        }
+
+        int alignment = randomBitIndex & 63;
+        if ((randomBitIndex >>> 6) == ((randomBitIndex + count) >>> 6)) {
+            long result = (randomBits[randomBitIndex >>> 6] >>> alignment) & ((1L << count) - 1);
+            randomBitIndex += count;
+            return result;
+        } else {
+            long result = (randomBits[randomBitIndex >>> 6] >>> alignment) & ((1L << (64 - alignment)) - 1);
+            randomBitIndex += count;
+            if (randomBitIndex >= MAX_RANDOM_BIT_INDEX) {
+                moreRandomBits();
+                randomBitIndex -= MAX_RANDOM_BIT_INDEX;
+            }
+            alignment = randomBitIndex & 63;
+            result <<= alignment;
+            result |= (randomBits[randomBitIndex >>> 6] >>> (64 - alignment)) & ((1L << alignment) - 1);
+
+            return result;
+        }
+    }
+
+    @Override
+    public @NotNull RandomSource fork() {
+        WorldgenCryptoRandom fork = new WorldgenCryptoRandom(0, 0, null, 0);
+
+        System.arraycopy(WorldSeedUtils.worldSeed, 0, fork.worldSeed, 0, WorldSeedUtils.WORLD_SEED_LONGS);
+        fork.message[0] = this.message[0];
+        fork.message[1] = this.message[1];
+        fork.message[2] = this.message[2];
+        fork.message[3] = this.message[3];
+        fork.randomBitIndex = this.randomBitIndex;
+        fork.counter = this.counter;
+        fork.nextLong();
+
+        return fork;
+    }
+
+    @Override
+    public int next(int bits) {
+        return (int) getBits(bits);
+    }
+
+    @Override
+    public void consumeCount(int count) {
+        randomBitIndex += count;
+        if (randomBitIndex >= MAX_RANDOM_BIT_INDEX * 2) {
+            randomBitIndex -= MAX_RANDOM_BIT_INDEX;
+            counter += randomBitIndex >>> LOG2_MAX_RANDOM_BIT_INDEX;
+            randomBitIndex &= MAX_RANDOM_BIT_INDEX - 1;
+            randomBitIndex += MAX_RANDOM_BIT_INDEX;
+        }
+    }
+
+    @Override
+    public int nextInt(int bound) {
+        int bits = Mth.ceillog2(bound);
+        int result;
+        do {
+            result = (int) getBits(bits);
+        } while (result >= bound);
+        return result;
+    }
+
+    @Override
+    public long nextLong() {
+        return getBits(64);
+    }
+
+    @Override
+    public double nextDouble() {
+        return getBits(53) * 0x1.0p-53;
+    }
+
+    @Override
+    public long setDecorationSeed(long worldSeed, int blockX, int blockZ) {
+        setSecureSeed(blockX, blockZ, WorldSeedUtils.Salt.POPULATION, 0);
+        return ((long) blockX << 32) | ((long) blockZ & 0xffffffffL);
+    }
+
+    @Override
+    public void setFeatureSeed(long populationSeed, int index, int step) {
+        setSecureSeed((int) (populationSeed >> 32), (int) populationSeed, WorldSeedUtils.Salt.DECORATION, index + 10000L * step);
+    }
+
+    @Override
+    public void setLargeFeatureSeed(long worldSeed, int chunkX, int chunkZ) {
+        super.setLargeFeatureSeed(worldSeed, chunkX, chunkZ);
+    }
+
+    @Override
+    public void setLargeFeatureWithSalt(long worldSeed, int regionX, int regionZ, int salt) {
+        super.setLargeFeatureWithSalt(worldSeed, regionX, regionZ, salt);
+    }
+
+    public static RandomSource seedSlimeChunk(int chunkX, int chunkZ) {
+        return new WorldgenCryptoRandom(chunkX, chunkZ, WorldSeedUtils.Salt.SLIME_CHUNK, 0);
+    }
+}
\ No newline at end of file
diff --git a/src/main/kotlin/one/tranic/levelpowered/bukkit/commands/LevelBukkitCfgCommand.kt b/src/main/kotlin/one/tranic/levelpowered/bukkit/commands/LevelBukkitCfgCommand.kt
new file mode 100644
index 0000000000000000000000000000000000000000..9f783600b1acd518562a8a267ee65543d76a4f83
--- /dev/null
+++ b/src/main/kotlin/one/tranic/levelpowered/bukkit/commands/LevelBukkitCfgCommand.kt
@@ -0,0 +1,34 @@
+package one.tranic.levelpowered.bukkit.commands
+
+import one.tranic.levelpowered.bukkit.config.LevelBukkitConfig
+import org.bukkit.command.Command
+import org.bukkit.command.CommandSender
+import net.kyori.adventure.text.Component
+import net.kyori.adventure.text.format.TextColor
+
+class LevelBukkitCfgCommand : Command("lbcfg") {
+    init {
+        this.permission = "levelbukkit.commands.cfg"
+        this.setDescription("Manage config file")
+        this.setUsage("/lbcfg")
+    }
+
+    override fun execute(sender: CommandSender, commandLabel: String, args: Array<String>): Boolean {
+        if (!this.testPermission(sender)) {
+            sender.sendMessage(
+                Component
+                    .text("No permission to execute this command!")
+                    .color(TextColor.color(255, 0, 0))
+            )
+        }
+
+        LevelBukkitConfig.reload()
+
+        sender.sendMessage(
+            Component
+                .text("Reloaded LevelBukkit config file!")
+                .color(TextColor.color(0, 255, 0))
+        )
+        return true
+    }
+}
\ No newline at end of file
diff --git a/src/main/kotlin/one/tranic/levelpowered/bukkit/config/LevelBukkitConfig.kt b/src/main/kotlin/one/tranic/levelpowered/bukkit/config/LevelBukkitConfig.kt
new file mode 100644
index 0000000000000000000000000000000000000000..7dcbc548d58a394fac277efb4cdcc32f5b3de0d1
--- /dev/null
+++ b/src/main/kotlin/one/tranic/levelpowered/bukkit/config/LevelBukkitConfig.kt
@@ -0,0 +1,195 @@
+package one.tranic.levelpowered.bukkit.config
+
+import gg.pufferfish.pufferfish.simd.SIMDDetection
+import net.minecraft.server.MinecraftServer
+import one.tranic.levelpowered.bukkit.commands.LevelBukkitCfgCommand
+import org.bukkit.Bukkit
+import org.bukkit.configuration.file.YamlConfiguration;
+import java.io.File
+
+object LevelBukkitConfig {
+    var logger: org.slf4j.Logger = MinecraftServer.LOGGER
+
+    @JvmStatic
+    fun setCommand() {
+        Bukkit.getCommandMap().register("lbcfg", "levelbukkit", LevelBukkitCfgCommand())
+    }
+
+    @JvmStatic
+    fun load() {
+        reload()
+        // Pufferfish start
+        // Attempt to detect vectorization
+        runCatching {
+            SIMDDetection.isEnabled = SIMDDetection.canEnable(logger)
+            SIMDDetection.versionLimited = SIMDDetection.getJavaVersion() < 17
+        }.getOrElse {
+            it.printStackTrace()
+        }
+
+        if (SIMDDetection.isEnabled) {
+            logger.info("SIMD operations detected as functional. Will replace some operations with faster versions.")
+        } else if (SIMDDetection.versionLimited) {
+            logger.warn("Will not enable SIMD! These optimizations are only safely supported on Java 17+.")
+        } else {
+            logger.warn("SIMD operations are available for your server, but are not configured!")
+            logger.warn("To enable additional optimizations, add \"--add-modules=jdk.incubator.vector\" to your startup flags, BEFORE the \"-jar\".")
+            logger.warn("If you have already added this flag, then SIMD operations are not supported on your JVM or CPU.")
+            logger.warn("Debug: Java: " + System.getProperty("java.version") + ", test run: " + SIMDDetection.testRun)
+        }
+    }
+
+    private fun addDefault(configFile: File, configuration: YamlConfiguration) {
+        // LevelBukkit start
+        configuration.addDefault("level.fix.disable-respawn-ceiling", false)
+        configuration.addDefault("level.fix.anvil-drop.enabled", false)
+        configuration.addDefault("level.fix.anvil-drop.debug", false)
+        // LevelBukkit end
+
+        // LevelBukkit: Divine start
+        configuration.addDefault("divine.recipe-manager-optimization", true)
+        configuration.addDefault("divine.secure-seed", false)
+        // LevelBukkit: Divine end
+
+        // LevelBukkit: Leaves start
+        configuration.addDefault("leaves.flatten-triangular-distribution", false)
+        configuration.addDefault("leaves.cache-world-generator-sea-level", false)
+        configuration.addDefault("leaves.vanilla-hopper", false)
+        // LevelBukkit: Leaves end
+
+        // LevelBukkit: Purpur start
+        configuration.addDefault("purpur.farmland-gets-moist-from-below", true)
+        configuration.addDefault("purpur.sensor-optimization", true)
+
+        configuration.addDefault("purpur.visibility-percent.skeleton-head", 0.5)
+        configuration.addDefault("purpur.visibility-percent.zombie-head", 0.5)
+        configuration.addDefault("purpur.visibility-percent.creeper-head", 0.5)
+        configuration.addDefault("purpur.visibility-percent.piglin-head", 0.5)
+
+        configuration.addDefault("purpur.villager-lobotomize.check-interval", 100)
+        configuration.addDefault("purpur.villager-lobotomize.enabled", false)
+        configuration.addDefault("purpur.villager-lobotomize.wait-until-trade-locked", false)
+        // LevelBukkit: Purpur end
+
+        configuration.options().copyDefaults(true)
+        configuration.save(configFile)
+    }
+
+    private fun loadConfigValue(configuration: YamlConfiguration) {
+        // LevelBukkit start
+        Level.Fix.tryFixAnvilDrop = configuration.getBoolean("level.fix.anvil-drop.enabled")
+        Level.Fix.tryFixAnvilDropDebug = configuration.getBoolean("level.fix.anvil-drop.debug")
+        Level.Fix.disableRespawnCeiling = configuration.getBoolean("level.fix.disable-respawn-ceiling")
+        // LevelBukkit end
+
+        // LevelBukkit: Divine start
+        Divine.secureSeed = configuration.getBoolean("divine.secure-seed")
+        Divine.recipeManagerOptimization = configuration.getBoolean("divine.recipe-manager-optimization")
+        // LevelBukkit: Divine end
+
+        // LevelBukkit: Leaves start
+        Leaves.flattenTriangularDistribution = configuration.getBoolean("leaves.flatten-triangular-distribution")
+        Leaves.cacheWorldGeneratorSeaLevel = configuration.getBoolean("leaves.cache-world-generator-sea-level")
+        Leaves.vanillaHopper = configuration.getBoolean("leaves.vanilla-hopper")
+        // LevelBukkit: Leaves end
+
+        // LevelBukkit: Purpur start
+        Purpur.World.farmlandGetsMoistFromBelow =
+            configuration.getBoolean("purpur.farmland-gets-moist-from-below")
+        Purpur.World.sensorOptimization = configuration.getBoolean("purpur.sensor-optimization")
+
+        Purpur.World.skeletonHeadVisibilityPercent =
+            configuration.getDouble("purpur.visibility-percent.skeleton-head")
+        Purpur.World.zombieHeadVisibilityPercent =
+            configuration.getDouble("purpur.visibility-percent.zombie-head")
+        Purpur.World.creeperHeadVisibilityPercent =
+            configuration.getDouble("purpur.visibility-percent.creeper-head")
+        Purpur.World.piglinHeadVisibilityPercent =
+            configuration.getDouble("purpur.visibility-percent.piglin-head")
+
+        Purpur.World.villagerLobotomizeCheckInterval =
+            configuration.getInt("purpur.villager-lobotomize.check-interval")
+        Purpur.World.villagerLobotomizeEnabled = configuration.getBoolean("purpur.villager-lobotomize.enabled")
+        Purpur.World.villagerLobotomizeWaitUntilTradeLocked =
+            configuration.getBoolean("purpur.villager-lobotomize.wait-until-trade-locked")
+        // LevelBukkit: Purpur end
+    }
+
+    @JvmStatic
+    fun reload() {
+        runCatching {
+            val configFile = File("levelbukkit.yml")
+            if (!configFile.exists()) {
+                configFile.createNewFile()
+            }
+            val configuration = YamlConfiguration.loadConfiguration(configFile)
+            addDefault(configFile, configuration)
+            loadConfigValue(configuration)
+        }.getOrElse {
+            throw RuntimeException(it)
+        }
+    }
+
+    object Level {
+        object Fix {
+            @JvmField
+            var disableRespawnCeiling: Boolean = false
+
+            @JvmField
+            var tryFixAnvilDrop: Boolean = false
+
+            @JvmField
+            var tryFixAnvilDropDebug: Boolean = false
+        }
+    }
+
+    object Divine {
+        @JvmField
+        var recipeManagerOptimization: Boolean = true
+
+        @JvmField
+        var secureSeed: Boolean = false
+    }
+
+    object Leaves {
+        @JvmField
+        var flattenTriangularDistribution: Boolean = false
+
+        @JvmField
+        var cacheWorldGeneratorSeaLevel: Boolean = false
+
+        @JvmField
+        var vanillaHopper: Boolean = false
+    }
+
+    class Purpur {
+        object World {
+            @JvmField
+            var farmlandGetsMoistFromBelow: Boolean = true
+
+            @JvmField
+            var sensorOptimization: Boolean = true
+
+            @JvmField
+            var skeletonHeadVisibilityPercent: Double = 0.0
+
+            @JvmField
+            var zombieHeadVisibilityPercent: Double = 0.5
+
+            @JvmField
+            var creeperHeadVisibilityPercent: Double = 0.5
+
+            @JvmField
+            var piglinHeadVisibilityPercent: Double = 0.5
+
+            @JvmField
+            var villagerLobotomizeCheckInterval: Int = 100
+
+            @JvmField
+            var villagerLobotomizeEnabled: Boolean = false
+
+            @JvmField
+            var villagerLobotomizeWaitUntilTradeLocked: Boolean = false
+        }
+    }
+}
\ No newline at end of file
